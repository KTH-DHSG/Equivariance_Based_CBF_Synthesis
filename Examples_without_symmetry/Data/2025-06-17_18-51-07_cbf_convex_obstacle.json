{
    "h": {
        "type": "function",
        "name": "h",
        "source": "def h(x):\n    \"\"\"\n    Constraint function h for the square with side length 4.\n\n    Args:\n        x (array-like): The point in the domain.\n\n    Returns:\n        h_value (float): The value of the constraint function.\n\n    \"\"\"\n\n    radius_3 = 7.0\n    radius_5 = 1.0\n\n    point_1 = np.array([0.0,15.0])\n    point_3 = point_1 + np.array([3.0,-radius_3])\n    point_4 = np.array([point_3[0]+radius_3,0.0])\n    point_5 = np.array([point_4[0]-radius_5,-10+radius_5+2*radius_5/np.sqrt(2)])\n\n    normal_6 = np.array([-1.0,-1.0])\n\n    h_1 = -x[0]\n    h_2 = x[1] - point_1[1]\n    h_3 = np.sqrt((x[0] - point_3[0])**2 + (x[1]-point_3[1])**2) - radius_3\n    h_4 = x[0] - point_4[0]\n    h_5 = np.sqrt((x[0] - point_5[0])**2 + (x[1]-point_5[1])**2) - radius_5\n    h_6 = np.dot(normal_6, x[0:2])\n\n    h_tmp = np.max([h_1, h_2, h_4, h_6])\n\n    if x[0] >= point_3[0] and x[1] >= point_3[1]:\n        h_tmp = np.max([h_tmp, h_3])\n\n    if x[1] <= point_5[1] and np.dot(np.array([1.0,-1.0]),x[0:2] - point_5) >= 0:\n        h_tmp = np.max([h_tmp, h_5])\n\n    return h_tmp\n\n    # return np.max([np.min([h_1, h_2, h_4, h_6]), h_3, h_5])\n"
    },
    "terminal_condition": null,
    "T": 7.808167079383925,
    "N": 30,
    "dt": 0.2602722359794642,
    "gamma": 0.1,
    "p_norm": 50,
    "p_norm_decrement": 10,
    "p_norm_min": 40,
    "domain_lower_bound": [
        -10.0,
        -15.0,
        -3.141592653589793
    ],
    "domain_upper_bound": [
        20.0,
        20.0,
        3.141592653589793
    ],
    "discretization": [
        41,
        41,
        41
    ],
    "warmStartInputTrajectories": null
}